"""RPG: Creatures in Pythonia

This script is a fun game centered in the world of Pythonia, where humans, elfs, chimps, and the mysterious Pythonians exist.

Once you input your name and intitiate the game, you'll become one of these species, given stats and health points (HP), and fight your way to the special enemy.

Each level before the last, you will be given a choice between three enemies, but will only be given their names (not their species).

Once you have selected an enemy, you will be given a difficulty based on the value of that enemy's primary stat, plus their vitality modifier. Then, if you choose to attack, you will roll a 20-sided die that determines your outcome. 

If you manage to roll a number greater than or higher than the difficulty, you win and pass the level. If not, you lose HP and have a chance to play again, unless your HP is 0.

The other option is to disengage, meaning you have no HP taken away, once the opponent attacks you.

When you reach the final level, you're given no choice, and must defeat the special enemy to win the entire game. The special enemy has more HP on average than other enemies, and their levels' difficulty is based on the value of two stats, instead of one.

If you manage to win the game, congrats, you are a star (and possibly the next ruler of Pythonia)!

And yes, there is an option for the user to play another game!

This file can be ran via terminal and contains the following classes:

  * Character: represents a character in the game, whether it's the user's player, or an enemy
  * Special Enemy: a version of the Character class specifically tailored to the opponent's final enemy
  * Stat: one of six abilities given to a character based on a dice roll, including its value and its modifier
  * Level: one of many options of levels that a user is given in a game, including its enemy, difficulty and HP loss
  * Die: an object that returns a number between one and its given number of sides, works when generating character stats and playing levels
  * Game: represents a full game, and contains the user's character, the levels, and the number of level that the user is currently on
"""

import random  # for dice rolling and more!

from tkinter import *

# COLOURS
WHITE = "#ffffff"
GREEN = "#008800"
RED = "#880000"
GOLD = "#ffd500"
SILVER = "#a0a0a0"

# ASCII characters and symbols
ELF = "   -   \n" \
      "  ---  \n" \
      " ----- \n" \
      "- . . -\n" \
      "-  v  -\n" \
      " ----- " \

HUMAN = "       \n" \
        "       \n" \
        " ----- \n" \
        "- * * -\n" \
        "-  =  -\n" \
        " ----- "

# looks like a cat, I know
CHIMP = "       \n" \
        "       \n" \
        " ^---^ \n" \
        "(.) (.)\n" \
        "-  o  -\n" \
        " ----- "

PYTHONIAN = "       \n" \
            "   s   \n" \
            " --p-- \n" \
            "- *_  -\n" \
            "-  _* -\n" \
            " --b-- "

DISENGAGE = "       \n" \
            "       \n" \
            "--   --\n" \
            "   -   \n" \
            "   -   \n" \
            "--   --\n"

ATTACK = "       \n" \
         "       \n" \
         "      ^\n" \
         " <---->\n" \
         "  -    \n" \
         "v      "

OP_ATTACK = "       \n" \
            "       \n" \
            "^      \n" \
            "<----> \n" \
            "    -  \n" \
            "      v\n"

# FONTS
REGULAR_FONT = ('Helvetica', 15)
BOLD_FONT = ('Helvetica', 15, 'bold')
SMALLER_FONT = ('Helvetica', 12)
SMALL_BOLD = ('Helvetica', 12, 'bold')

# OOP: Classes for Character, Stat, Level, Die, and Game

class Character:
  
  """
    A class used to represent a character in the game, whether it's the user's player, or an enemy.

    ...

    Attributes
    ----------
    name : str
        the name of the character, as chosen by the player if it's their character or randomly generated by the computer if it's an enemy
    gender : str
        the gender of the character, also either chosen by player or randomly generated
        - male: character is purely masculine
        - female: character is purely feminine
        - nonbinary: character is neither masculine nor feminine
        - androgynous: character is both masculine and feminine
    species : str
        the species in Pythonia that the character belongs to; always randomly generated by computer
        - Human: between 30 and 50 HP
        - Elf: between 10 and 30 HP
        - Chimp: between 50 and 70 HP
        - Pythonian: between 10 and 70 HP
    avatar : List(str)
        based on species
    hp: int
        the amount of health points (HP) the character has, as determined by species
    stats : dict(str, Stat)
        - Power (PWR): how hard you can hit something
        - Speed (SPD): how fast and flexibly you can move
        - Vitality (VIT): how resistant you are to attacks
        - Foresight (FRS): how perceptive you are
        - Aptitude (APT): how much you know about things
        - Extraversion (EXT): how good you are with people
    type : str
        generated based on a character's primary stat (stat of highest value)
        - Jock (primary stat is Power)
        - Acrobat (primary stat is Speed)
        - Rebel (primary stat is Vitality)
        - Psychic (primary stat is Foresight)
        - Geek (primary stat is Aptitude)
        - Socialite (primary stat is Extraversion)
        if there is a tie for the primary stat, the selection of this attribute will be randomized
    defense:
      the number that the other player must exceed to successfully attack the character
    damage:
      how much damage is dealt by the character in a regular attack
    primary_stat : str
        the code of the character's primary stat

    Methods
    -------
    get_stats() -> str
        Returns a string containing all information about the character
  
    """
  
  def __init__(self, name=None, gender=None):

    # set name if chosen by user
    if name is not None:
      self.name = name

    # set gender
    if gender is not None:
      self.gender = gender
    else:
      genders = ['male', 'female', 'nonbinary', 'androgynous']
      self.gender = random.choice(genders)

    # set species
    species = ['human', 'elf', 'chimp', 'pythonian']
    self.species = random.choice(species)

    # set health points
    if self.species == 'human':
      self.avatar = HUMAN
      self.hp = random.randint(30,50) 
    elif self.species == 'elf':
      self.avatar = ELF
      self.hp = random.randint(10,30)
    elif self.species == 'chimp':
      self.avatar = CHIMP
      self.hp = random.randint(50,70)
    elif self.species == 'pythonian':
      self.avatar = PYTHONIAN
      self.hp = random.randint(10,70)

    # set stats
    self.stats = {
      'PWR': Stat('PWR'),
      'SPD': Stat('SPD'),
      'VIT': Stat('VIT'),
      'FRS': Stat('FRS'),
      'APT': Stat('APT'),
      'EXT': Stat('EXT')
    }

    # set primary_stat
    primary_stat_contenders = []

    maximum_value = max([s.get_value() for s in self.stats.values()])

    for code, stat in self.stats.items():
      if stat.get_value() == maximum_value:
        primary_stat_contenders.append(code)

    self.primary_stat = random.choice(primary_stat_contenders)

    # set type
    if self.primary_stat == 'PWR':
      self.type = 'Jock'
      self.stats['APT'].value //= 2 # divide by 2 and round down
    elif self.primary_stat == 'SPD':
      self.type = 'Acrobat'
      self.stats['EXT'].value //= 2
    elif self.primary_stat == 'VIT':
      self.type = 'Rebel'
      self.stats['FRS'].value //= 2
    elif self.primary_stat == 'FRS':
      self.type = 'Psychic'
      self.stats['VIT'].value //= 2
    elif self.primary_stat == 'APT':
      self.type = 'Geek'
      self.stats['PWR'].value //= 2
    elif self.primary_stat == 'EXT':
      self.type = 'Socialite'
      self.stats['SPD'].value //= 2

    # set name if not chosen by user
    if name is None:
      self.name = self.type + '#' + "%03d" % random.randint(1,999) # formats each number to three digits

    self.defense = self.stats[self.primary_stat].get_value() + self.stats['VIT'].get_modifier()
    self.damage = int(self.hp // 4)

      
  def get_stats(self):
    return f"\nName: {self.name}\n"\
    f"Gender: {self.gender}\n" \
    f"Species: {self.species}\n" \
    f"Type: {self.type}\n" \
    f"HP: {self.hp}\n" \
    f"Stats:\n" \
    f"\tPower: {self.stats['PWR'].get_value()}\n" \
    f"\tSpeed: {self.stats['SPD'].get_value()}\n" \
    f"\tVitality: {self.stats['VIT'].get_value()}\n" \
    f"\tForesight: {self.stats['FRS'].get_value()}\n" \
    f"\tAptitude: {self.stats['APT'].get_value()}\n" \
    f"\tExtraversion: {self.stats['EXT'].get_value()}\n" \
    f"Primary Stat: {self.stats[self.primary_stat].name}"


class SpecialEnemy(Character):

  """
    A class that is a version of the Character class specifically tailored to the opponent's final enemy

    ...

    Attributes
    ----------
    name : str
        the name of the character, which is a sequence of three characters randomly generated by the computer
    gender : str
        the gender of the character, also either chosen by player or randomly generated
        - male: character is purely masculine
        - female: character is purely feminine
        - nonbinary: character is neither masculine nor feminine
        - androgynous: character is both masculine and feminine
    species : str
        the species in Pythonia that the character belongs to; always randomly generated by computer
      - Golden Human: between 70 and 90 HP
      - Silver Human: between 50 and 70 HP
      - Golden Elf: between 50 and 70 HP
      - Silver Elf: between 30 and 50 HP
      - Golden Chimp: between 90 and 110 HP
      - Silver Chimp: between 70 and 90 HP
      - Golden Pythonian: betwen 50 and 110 HP
      - Silver Pythonian: between 30 and 90 HP
    avatar : str
        based on species
    avatar_color: str
        also based on species
    hp: int
        the amount of health points (HP) the character has, as determined by species
    stats : dict(str, Stat)
        - Power (PWR): how hard you can hit something
        - Speed (SPD): how fast and flexibly you can move
        - Vitality (VIT): how resistant you are to attacks
        - Foresight (FRS): how perceptive you are
        - Aptitude (APT): how much you know about things
        - Extraversion (EXT): how good you are with people
    type : str
        generated based on a character's primary stat (stat of highest value) and secondary stat (stat of second highest value)
        - Brawny Jock (primary stat is Power and secondary stat is either Speed or Vitality)
        - Brainy Jock (primary stat is Power and secondary stat is either Foresight, Aptitude, or Extraversion)
        - Brawny Acrobat (primary stat is Speed and secondary stat is either Power or Vitality)
        - Brainy Acrobat (primary stat is Speed and secondary stat is either Foresight, Aptitude, or Extraversion)
        - Brawny Rebel (primary stat is Vitality and secondary stat is either Power or Speed)
        - Brainy Rebel (primary stat is Vitality and secondary stat is either Foresight, Aptitude, or Extraversion)
        - Brawny Psychic (primary stat is Foresight and secondary stat is either Power, Speed, or Vitality)
        - Brainy Psychic (primary stat is Foresight and secondary stat is either Aptitude or Extraversion)
        - Brawny Geek (primary stat is Aptitude and secondary stat is either Power, Speed, or Vitality)
        - Brainy Geek (primary stat is Aptitude and secondary stat is either Foresight or Extraversion)
        - Brawny Socialite (primary stat is Extraversion and secondary stat is either Power, Speed, or Vitality)
        - Brainy Socialite (primary stat is Extraversion and secondary stat is either Foresight or Aptitude)
        if there is a tie for the primary stat, the selection of this attribute will be randomized, and if all stats are of the same value, the selecion of both primary and secondary stat will be randomized
    defense:
      the number that the other player must exceed to successfully attack the character
    damage:
      how much damage is dealt by the character in a regular attack
    primary_stat : str
        the code of the character's primary stat
    secondary_stat : str
        the code of the enemy's secondary stat

    Methods
    -------
    get_stats() -> str
        Returns a string containing all information about the character
  
    """

  def __init__(self):
    # set name, which is never chosen by user
    chars = [chr(i) for i in range(ord('!'), ord('{'))]
    self.name = random.choice(chars) + random.choice(chars) + random.choice(chars)

    # set gender
    genders = ['male', 'female', 'nonbinary', 'androgynous']
    self.gender = random.choice(genders)

    # set species
    species = ['golden human', 'silver human', 'golden elf', 'silver elf', 'golden chimp', 'silver chimp', 'golden pythonian', 'silver pythonian']
    self.species = random.choice(species)

    # set health points
    if self.species in ['golden human', 'silver chimp']:
      if self.species == 'golden human':
        self.avatar = HUMAN
        self.avatar_color = GOLD
      if self.species == 'silver chimp':
        self.avatar = CHIMP
        self.avatar_color = SILVER
      self.hp = random.randint(70, 90)
    elif self.species in ['silver human', 'golden elf']:
      if self.species == 'silver human':
        self.avatar = HUMAN
        self.avatar_color = SILVER
      if self.species == 'golden elf':
        self.avatar = ELF
        self.avatar_color = GOLD
      self.hp = random.randint(50, 70)
    elif self.species == 'silver elf':
      self.avatar = ELF
      self.avatar_color = SILVER
      self.hp = random.randint(30, 50)
    elif self.species == 'golden chimp':
      self.avatar = CHIMP
      self.avatar_color = GOLD
      self.hp = random.randint(90, 110)
    elif self.species == 'golden pythonian':
      self.avatar = PYTHONIAN
      self.avatar_color = GOLD
      self.hp = random.randint(50, 110)
    elif self.species == 'silver pythonian':
      self.avatar = PYTHONIAN
      self.avatar_color = SILVER
      self.hp = random.randint(30, 90)

    # set stats
    self.stats = {
      'PWR': Stat('PWR'),
      'SPD': Stat('SPD'),
      'VIT': Stat('VIT'),
      'FRS': Stat('FRS'),
      'APT': Stat('APT'),
      'EXT': Stat('EXT')
    }

    # set primary_stat and secondary_stat
    primary_stat_contenders = []

    secondary_stat_contenders = []

    maximum_value = max([s.get_value() for s in self.stats.values()])

    for code, stat in self.stats.items():
      if stat.get_value() == maximum_value:
        primary_stat_contenders.append(code)

    second_max_value = 0

    for code, stat in self.stats.items():
      if stat.get_value() != maximum_value and stat.get_value() > second_max_value:
        second_max_value = stat.value

    if second_max_value == 0:
      self.primary_stat = random.choice(primary_stat_contenders)
      del primary_stat_contenders[primary_stat_contenders.index(self.primary_stat)]
      self.secondary_stat = random.choice(primary_stat_contenders)
    else:
      for code, stat in self.stats.items():
        if stat.get_value() == second_max_value:
          secondary_stat_contenders.append(code)
      self.primary_stat = random.choice(primary_stat_contenders)
      self.secondary_stat = random.choice(secondary_stat_contenders)

    self.damage = int(self.hp // 3)
    self.defense = int((self.stats[self.primary_stat].get_value() + self.stats[self.secondary_stat].get_value()) // 2) + self.stats['VIT'].get_modifier()

    # set type
    if self.primary_stat == 'PWR':
      if self.secondary_stat in ['SPD', 'VIT']:
        self.type = "Brawny Jock"
        self.stats['APT'].value //= 1.5 # divide by 1.5 and round down
        self.stats['APT'].value = int(self.stats['APT'].value)
      else:
        self.type = "Brainy Jock"
        self.stats['VIT'].value //= 1.5
        self.stats['VIT'].value = int(self.stats['VIT'].value)
    elif self.primary_stat == 'SPD':
      if self.secondary_stat in ['PWR', 'VIT']:
        self.type = "Brawny Acrobat"
        self.stats['EXT'].value //= 1.5
        self.stats['EXT'].value = int(self.stats['EXT'].value)
      else:
        self.type = "Brainy Acrobat"
        self.stats['PWR'].value //= 1.5
        self.stats['PWR'].value = int(self.stats['PWR'].value)
    elif self.primary_stat == 'VIT':
      if self.secondary_stat in ['PWR', 'SPD']:
        self.type = "Brawny Rebel"
        self.stats['FRS'].value //= 1.5
        self.stats['FRS'].value = int(self.stats['FRS'].value)
      else:
        self.type = "Brainy Rebel"
        self.stats['SPD'].value //= 1.5
        self.stats['SPD'].value = int(self.stats['SPD'].value)
    elif self.primary_stat == 'FRS':
      if self.secondary_stat in ['APT', 'EXT']:
        self.type = "Brainy Psychic"
        self.stats['VIT'].value //= 1.5
        self.stats['VIT'].value = int(self.stats['VIT'].value)
      else:
        self.type = "Brawny Psychic"
        self.stats['EXT'].value //= 1.5
        self.stats['EXT'].value = int(self.stats['EXT'].value)
    elif self.primary_stat == 'APT':
      if self.secondary_stat in ['FRS', 'EXT']:
        self.type = "Brainy Geek"
        self.stats['PWR'].value //= 1.5
        self.stats['PWR'].value = int(self.stats['PWR'].value)
      else:
        self.type = "Brawny Geek"
        self.stats['FRS'].value //= 1.5
        self.stats['FRS'].value = int(self.stats['FRS'].value)
    elif self.primary_stat == 'EXT':
      if self.secondary_stat in ['FRS', 'APT']:
        self.type = "Brainy Socialite"
        self.stats['SPD'].value //= 1.5
        self.stats['SPD'].value = int(self.stats['SPD'].value)
      else:
        self.type = "Brawny Socialite"
        self.stats['APT'].value //= 1.5
        self.stats['APT'].value = int(self.stats['APT'].value)

  
  def get_stats(self):
    return super().get_stats() + f"\nSecondary Stat: {self.stats[self.secondary_stat].name}" # since its mostly like the Character class
    

class Stat:

  """
    A class representing one of six abilities given to a character based on a dice roll, including its value and its modifier. 

    ...

    Attributes
    ----------
    name : str
        the name of the stat
    code : str
        the three-letter code representing the stat (just input)
    value : int
        random number generated from 4 6-sided die rolls
    modifier: int
        the value divided by 5 and rounded down

    Methods
    -------
    get_value() -> int
        Returns the value of the stat
    get_modifier() -> int
        Returns the modifier of the stat
  
    """

  def __init__(self, code):
    # set name based on code
    if code == 'PWR':
      self.name = 'power'
    elif code == 'SPD':
      self.name = 'speed'
    elif code == 'VIT':
      self.name = 'vitality'
    elif code == 'FRS':
      self.name = 'foresight'
    elif code == 'APT':
      self.name = 'aptitude'
    elif code == 'EXT':
      self.name = 'extraversion'

    # set value
    values = []

    for _ in range(4):
      values.append(Die(6).roll())

    self.value = sum(sorted(values)[1:])

    # set mmodifier
    self.modifier = self.value // 5

  def get_value(self):
    return self.value

  def get_modifier(self):
    return self.modifier
    

class Level:
  
  """
    A class representing one of many options of levels that a user is given in a game, including its enemy, difficulty and HP loss. 
  
    ...

    Attributes
    ----------
    opponent : Character
        the opponent that the protagonist (user) must face
    key_stat : str
        the code of the stat added as a modifier in this level; based on opponent's type
    difficulty : int
        the number that must be met or exceeded for protagonist to beat the level
    outcome: str (UPDATE: not an actual attribute of the class, just a reference)
        represents the outcome of a roll in the level
        - total success: the number is greater than or equal to 20, extra HP gained
        - success: the number is higher than the difficulty, but less than 20, HP reset when done
        - sweet spot: the number is exactly the difficulty, nothing happens
        - failure: the number is lower than difficulty, but higher than 5, HP lost
        - total failure: the number is less than or equal to 5, extra HP lost, with no chance to redo
    roller : Die
        the 20-sided-die (d20) that determines the fate of this level
  
    Methods
    -------
    play(protagonist : Character) 
        Plays the level
    get_difficulty() -> int
        Returns the difficulty of the level
    get_opponent() -> Character
        Returns the opponent to beat in this level
  
  """
  def __init__(self, is_special_enemy=False):
    if not is_special_enemy:
      self.opponent = Character()
    else: # if it's a special enemy level
      self.opponent = SpecialEnemy()

    self.key_stat = self.opponent.primary_stat

    self.difficulty = self.opponent.defense

    self.roller = Die(20)

  

  def get_difficulty(self):
    return self.difficulty

  def get_opponent(self):
    return self.opponent

class Die:

  """
    A class representing an object that returns a number between one and its given number of sides, works when generating character stats and playing levels. 

    ...

    Attributes
    ----------
    number_sides : int
        the number of "sides" the die has
    value_rolled : int
        the value generated from a roll, which is between 1 and number_sides
  
    Methods
    -------
    roll() ->
        Rolls the die and returns the value
  
    """

  def __init__(self, number_sides):
    self.number_sides = number_sides
    self.value_rolled = 0  # left at zero since it has to be rolled

  def roll(self): # rolls the die!
    self.value_rolled = random.randint(1, self.number_sides)
    return self.value_rolled


class Game: 

  """
    A class representing a full game, and contains the user's character, the levels, and the number of level that the user is currently on 

    ...

    Attributes
    ----------
    protagonist : Character
        the user's character
    levels : [Level]
        the list of levels that will be played in the game; a partially two-dimensional array, as each array within this set will be a list of options for the player to choose from, while the very last element whill be a special enemy
    level_number : int
        the number of level the protagonist is currently on during the game
    current_enemy : Character
        the enemy selected (or special enemy) for the the level the protagonist is currently on
  
    Methods
    -------
    give_options() 
        Gives the protagonist level options (enemies) to choose from, except if it's the only option (special enemy)
    game_info() -> str
        Returns information about the current game, such as level number, the name of the enemy etc.
  
    """

  def __init__(self, protagonist):
    self.protagonist = protagonist

    self.levels = []

    for _ in range(3):
      self.levels.append([Level(), Level(), Level()])

    self.levels.append(Level(True))

    self.level_number = 1

    self.current_enemy = None

  def game_info(self):
    return "Total Levels: 4\n" \
    f"Current Level Number: {self.level_number}\n" \
    f"Levels Left: {4 - self.level_number}\n" \
    f"Name of Current Enemy: {self.current_enemy.name}"

# to transition between pages (dynamic GUI)
def page_transition(widgets):
  for widget in widgets.values():
    widget.destroy() # deletes the widget
  widgets = dict()
  return widgets # returns as an empty dict

# intialize GUI
def launch_rpg():
  win = Toplevel()
  win.title("Creatures in Pythonia")
  win.geometry("600x400")

  widgets = dict()

  # welcome text
  widgets['welcome_1'] = Label(win, text="Welcome to Creatures of Pythonia!", font=BOLD_FONT)
  widgets['welcome_1'].place(x=300, y=150, anchor='c') # close to center
  widgets['welcome_2'] = Label(win, text="A whole other world awaits!", font=REGULAR_FONT)
  widgets['welcome_2'].place(x=300, y=180, anchor='c') # close to center

  # button to start game 
  widgets['start'] = Button(win, text="START", fg=GREEN, command=lambda:create_character(win, widgets))
  widgets['start'].place(x=300, y=210, anchor='c') # below welcome

  win.mainloop()

# to choose name and gender
def create_character(win, widgets):
  widgets = page_transition(widgets)

  # choose name
  widgets['name_frame'] = Frame(win)
  widgets['name_frame'].place(x=300, y=110, anchor='c')

  widgets['name_label'] = Label(widgets['name_frame'], text="What would you like to name your character?", font=SMALLER_FONT)
  widgets['name_label'].pack(side=LEFT)

  widgets['name_entry'] = Entry(widgets['name_frame'], width=10)
  widgets['name_entry'].pack(side=RIGHT)

  # choose gender
  widgets['gender_frame'] = Frame(win)
  widgets['gender_frame'].place(x=300, y=150, anchor='c')

  widgets['gender_label'] = Label(widgets['gender_frame'], text="What is your character's gender?", font=SMALLER_FONT)
  widgets['gender_label'].pack(side=LEFT)

  gender_var = StringVar()

  widgets['gender_select'] = OptionMenu(widgets['gender_frame'], gender_var, *['male', 'female', 'nonbinary', 'androgynous'])
  widgets['gender_select'].pack(side=RIGHT)

  # submit/continue button
  widgets['submit'] = Button(win, text="Continue", command=lambda:exposition_1(win, widgets, widgets['name_entry'].get(), gender_var.get()))
  widgets['submit'].place(x=300, y=250, anchor='c')

# exposition pages
def exposition_1(win, widgets, name, gender):
  widgets = page_transition(widgets)

  # create new character from name and gender
  you = Character(name, gender)

  # display first part of exposition text
  widgets['exp_text'] = Text(win, wrap=WORD, font=SMALLER_FONT)
  widgets['exp_text'].insert(INSERT, "Four species exist in the planet of Pythonia: humans, elfs, chimps, and the mysterious Pythonians")

  widgets['exp_text'].insert(INSERT, "\n\tHumans are just like you and me (unless you are another animal or robot that is)")
  widgets['exp_text'].insert(INSERT, "\n\tElfs are short and stumpy, dwelling low inside holes and caves")
  widgets['exp_text'].insert(INSERT, "\n\tChimps prefer to live much high than that and can come swinging by any time")
  widgets['exp_text'].insert(INSERT, "\n\tNot much is known about Pythonians, but rumour has it they're good at hacking (whatever that means)")

  widgets['exp_text'].insert(INSERT, "\nThere are also GOLD and SILVER versions of these species that exist, but we'll get to those later")

  # change colours and styles of certain parts of Text
  widgets['exp_text'].tag_add("HUMANS", "2.1", "2.7")
  widgets['exp_text'].tag_config("HUMANS", font=SMALL_BOLD)
  widgets['exp_text'].tag_add("ELFS", "3.1", "3.5")
  widgets['exp_text'].tag_config("ELFS", font=SMALL_BOLD)
  widgets['exp_text'].tag_add("CHIMPS", "4.1", "4.7")
  widgets['exp_text'].tag_config("CHIMPS", font=SMALL_BOLD)
  widgets['exp_text'].tag_add("PYTHONIANS", "5.25", "5.35")
  widgets['exp_text'].tag_config("PYTHONIANS", font=SMALL_BOLD)
  widgets['exp_text'].tag_add("GOLD", "6.15", "6.19")
  widgets['exp_text'].tag_config("GOLD", font=SMALL_BOLD, foreground=GOLD)
  widgets['exp_text'].tag_add("SILVER", "6.24", "6.31")
  widgets['exp_text'].tag_config("SILVER", font=SMALL_BOLD, foreground=SILVER)

  widgets['exp_text'].pack()
  widgets['exp_text'].configure(state='disabled')

  # button to continue
  widgets['continue'] = Button(win, text="Continue", command=lambda:exposition_2(win, widgets, you))
  widgets['continue'].place(x=300, y=250, anchor='c')

def exposition_2(win, widgets, character):
  widgets = page_transition(widgets)

  # get your species
  species = character.species[0].upper() + character.species[1:]

  # display second part of exposition text
  widgets['exp_text'] = Text(win, wrap=WORD, font=SMALLER_FONT)
  widgets['exp_text'].insert(INSERT, f"You are a {species}!")

  widgets['exp_text'].insert(INSERT, "\n" + character.avatar)

  widgets['exp_text'].insert(INSERT, "\nThere are also six types, universal to each species, based on their personality (in other words, their dominant characteristic)!")

  # change colours and styles of certain parts of Text
  widgets['exp_text'].tag_add("SPECIES", "1.9", "1."+str(len(species) + 10))
  widgets['exp_text'].tag_config("SPECIES", font=SMALL_BOLD)

  widgets['exp_text'].pack()
  widgets['exp_text'].configure(state='disabled')

  # button to continue
  widgets['continue'] = Button(win, text="Continue", command=lambda:exposition_3(win, widgets, character))
  widgets['continue'].place(x=300, y=250, anchor='c')

def exposition_3(win, widgets, character):
  widgets = page_transition(widgets)

  # display final part of exposition text
  widgets['exp_text'] = Text(win, wrap=WORD, font=SMALLER_FONT)
  
  widgets['exp_text'].insert(INSERT, "\tJocks are strong and pack a ton of muscle")
  widgets['exp_text'].insert(INSERT, "\n\n\tAcrobats are fast and extremely flexible")
  widgets['exp_text'].insert(INSERT, "\n\n\tRebels can easily defend themselves with their thick skin")
  widgets['exp_text'].insert(INSERT, "\n\n\tPsychics can see into the future and anticipate every move")
  widgets['exp_text'].insert(INSERT, "\n\n\tGeeks are very knowledgeable, let's say book smart actually")
  widgets['exp_text'].insert(INSERT, "\n\n\tSocialites have such charm and are good at persuading others")

  # get your type
  type = character.type

  widgets['exp_text'].insert(INSERT, f"\n\nOh, you are a {type}!")

  # change colours and styles of certain parts of Text
  widgets['exp_text'].tag_add("JOCKS", "1.0", "1.6")
  widgets['exp_text'].tag_config("JOCKS", font=SMALL_BOLD)
  widgets['exp_text'].tag_add("ACROBATS", "3.0", "3.9")
  widgets['exp_text'].tag_config("ACROBATS", font=SMALL_BOLD)
  widgets['exp_text'].tag_add("REBELS", "5.0", "5.7")
  widgets['exp_text'].tag_config("REBELS", font=SMALL_BOLD)
  widgets['exp_text'].tag_add("PSYCHICS", "7.0", "7.9")
  widgets['exp_text'].tag_config("PSYCHICS", font=SMALL_BOLD)
  widgets['exp_text'].tag_add("GEEKS", "9.0", "9.6")
  widgets['exp_text'].tag_config("GEEKS", font=SMALL_BOLD)
  widgets['exp_text'].tag_add("SOCIALITES", "11.0", "11.11")
  widgets['exp_text'].tag_config("SOCIALITES", font=SMALL_BOLD)

  widgets['exp_text'].pack()
  widgets['exp_text'].configure(state='disabled')

  # button to continue
  widgets['continue'] = Button(win, text="Continue", command=lambda:display_character_info(win, widgets, character))
  widgets['continue'].place(x=300, y=290, anchor='c')

def display_character_info(win, widgets, character):
  widgets = page_transition(widgets)

  # display second part of exposition text
  widgets['info_text'] = Text(win, wrap=WORD, font=SMALLER_FONT)
  widgets['info_text'].insert(INSERT, "Here's your character's complete information:")

  widgets['info_text'].insert(INSERT, "\n" + character.get_stats())

  widgets['info_text'].pack()
  widgets['info_text'].configure(state='disabled')

  game = Game(character)
  max_hp = character.hp # for healing

  # button to continue
  widgets['continue'] = Button(win, text="Continue", command=lambda:main_game(win, widgets, character, game, max_hp))
  widgets['continue'].place(x=300, y=320, anchor='c')

def main_game(win, widgets, character, game, max_hp):
  widgets = page_transition(widgets)

  if character.hp == 0:
    widgets['message'] = Label(win, text="GAME OVER!", font=BOLD_FONT, fg=RED)
    widgets['message'].place(x=300, y=200, anchor='c')
  elif game.level_number >= 5:
    widgets['message'] = Label(win, text="GAME COMPLETE!", font=BOLD_FONT, fg=GREEN)
    widgets['message'].place(x=300, y=200, anchor='c')
  else:
    widgets['message'] = Label(win, text="What would you like to do?", font=REGULAR_FONT)
    widgets['message'].place(x=300, y=150, anchor='c')

    # another dropdown
    choices = ['Instructions', 'Heal', 'Battle', 'Get Game Info', 'Get Character Info']
    choice_var = StringVar()
    widgets['choice_select'] = OptionMenu(win, choice_var, *choices)
    widgets['choice_select'].place(x=300, y=200, anchor='c')

    widgets['submit'] = Button(win, text="Submit", command=lambda:evaluate_choice(win, widgets, character, game, max_hp, choice_var.get()))
    widgets['submit'].place(x=300, y=280, anchor='c')

def evaluate_choice(win, widgets, character, game, max_hp, choice):
  if choice == "Instructions":
    instructions(win, widgets, character, game, max_hp)
  elif choice == "Heal":
    heal(win, widgets, character, game, max_hp)
  elif choice == "Battle":
    battle(win, widgets, character, game, max_hp)
  elif choice == "Get Game Info":
    get_game_info(win, widgets, character, game, max_hp)
  elif choice == "Get Character Info":
    get_character_info(win, widgets, character, game, max_hp)

def instructions(win, widgets, character, game, max_hp):
  widgets = page_transition(widgets)

  widgets['instructions_text'] = Text(win, wrap=WORD, font=SMALLER_FONT)

  widgets['instructions_text'].insert(INSERT, "The objective of this game is to defeat an enemy and knock out all their health points.")
  widgets['instructions_text'].insert(INSERT, "\nOn each turn or round:")
  widgets['instructions_text'].insert(INSERT, "\nIf you select 'Disengage', you won't lose or gain any health points")
  widgets['instructions_text'].insert(INSERT, "\nHowever, if you select 'Attack', you must roll a die to determine an outcome.")
  widgets['instructions_text'].insert(INSERT, "\nIf you roll a number higher than the difficulty when added to a certain modifier, you may take away HP from the enemy.")
  widgets['instructions_text'].insert(INSERT, "\n(And we say 'may' because the enemy might decide to disengage during their turn)")
  widgets['instructions_text'].insert(INSERT, "\nThere's even a chance you might gain extra HP if you select this option...")
  widgets['instructions_text'].insert(INSERT, "\n\nGood day and good luck!")

  widgets['instructions_text'].pack()
  widgets['instructions_text'].configure(state='disabled')

  widgets['continue'] = Button(win, text="Continue", command=lambda:main_game(win, widgets, character, game, max_hp))
  widgets['continue'].place(x=300, y=280, anchor='c')

def heal(win, widgets, character, game, max_hp):
  widgets = page_transition(widgets)

  widgets['warning_header'] = Label(win, text="WARNING BEFORE YOU HEAL:", font=BOLD_FONT, fg=RED)
  widgets['warning_header'].place(x=300, y=100, anchor='c')

  widgets['warning_text'] = Label(win, text="You will be rolled a d10 for this move \nso there is a small chance that you will GAIN something, \nbut also that you will lose something", font=SMALL_BOLD)
  widgets['warning_text'].place(x=300, y=150, anchor='c')

  widgets['question'] = Label(win, text="Are you still willing to take this risk?", font=SMALL_BOLD, fg=RED)

  widgets['buttons_frame'] = Frame(win)
  widgets['buttons_frame'].place(x=300, y=250, anchor='c')

  # yes and no buttons
  widgets['yes_button'] = Button(widgets['buttons_frame'], text="Yes", command=lambda:healing(win, widgets, character, game, max_hp))
  widgets['yes_button'].pack(side=LEFT)

  widgets['no_button'] = Button(widgets['buttons_frame'], text="No", command=lambda:main_game(win, widgets, character, game, max_hp))
  widgets['no_button'].pack(side=RIGHT)

  def healing(win, widgets, character, game, max_hp):
    widgets = page_transition(widgets)

    heal_value = Die(10).roll()

    widgets['rolled_message'] = Label(win, text=f"You rolled a {heal_value}!", font=REGULAR_FONT)
    widgets['rolled_message'].place(x=300, y=150, anchor='c')

    widgets['outcome_message'] = Label(win, font=BOLD_FONT)
    widgets['outcome_message'].place(x=300, y=200, anchor='c')

    if heal_value == 1 or heal_value == 10:
      character.hp = max_hp
      widgets['outcome_message'].configure(fg=GREEN, text="Your HP has been restored!")
    elif heal_value == 4 or heal_value == 6:
      character.hp -= 10
      widgets['outcome_message'].configure(fg=RED, text="The potion backfired! You lost 10 HP!")
    else:
      widgets['outcome_message'].configure(text="You got nothing, sorry.")

    widgets['continue'] = Button(win, text="Continue", command=lambda:main_game(win, widgets, character, game, max_hp))
    widgets['continue'].place(x=300, y=280, anchor='c')

def battle(win, widgets, character, game, max_hp):
  widgets = page_transition(widgets)

  # give game's options
  if type(game.levels[game.level_number - 1]) != type(Level()): # checks if there are options
    widgets['message'] = Label(win, text="Here are your options:", font=BOLD_FONT)
    widgets['message'].place(x=300, y=150, anchor='c')
    option_list = game.levels[game.level_number -1]
    options = [option_list[i].get_opponent().name for i in range(3)]
    opponent_var = StringVar()
    widgets['opponent_select'] = OptionMenu(win, opponent_var, *options)
    widgets['opponent_select'].place(x=300, y=200, anchor='c')
    widgets['opponent_submit'] = Button(win, text="Let's go!", command=lambda:select_enemy(win, widgets, character, game, max_hp, option_list, opponent_var.get()))
    widgets['opponent_submit'].place(x=300, y=250, anchor='c')

    def select_enemy(win, widgets, character, game, max_hp, option_list, enemy_name):
      for i in range(len(option_list)):
        if option_list[i].get_opponent().name == enemy_name:
          game.current_enemy = option_list[i].get_opponent()
          play_level(win, widgets, character, game, max_hp, option_list[i])
          game.level_number += 1
  else:
    widgets['message'] = Label(win, text="Final round!", font=BOLD_FONT)
    widgets['message'].place(x=300, y=150, anchor='c')
    game.current_enemy = game.levels[game.level_number - 1].get_opponent()
    play_level(win, widgets, character, game, max_hp, game.levels[game.level_number - 1])
    game.level_number += 1

def play_level(win, widgets, character, game, max_hp, level):
  widgets = page_transition(widgets)

  # introduce the enemy
  widgets['enemy'] = Text(win, wrap=WORD, font=SMALLER_FONT)
  widgets['enemy'].insert(INSERT, "Challenge accepted!")
  widgets['enemy'].insert(INSERT, "\n\n" + level.opponent.avatar)
  widgets['enemy'].insert(INSERT, "\n" + level.opponent.get_stats())
  widgets['enemy'].pack()
  widgets['enemy'].configure(state='disabled') 

  widgets['continue'] = Button(win, text="Continue", command=lambda:actually_playing_the_level(win, widgets, character, game, max_hp, level))
  widgets['continue'].place(x=300, y=280, anchor='c')

  def actually_playing_the_level(win, widgets, character, game, max_hp, level):
    widgets = page_transition(widgets)

    # reveal the difficulty
    widgets['difficulty'] = Text(win, wrap=WORD, font=SMALLER_FONT)
    widgets['difficulty'].insert(INSERT, f"This level has a difficulty of {level.difficulty}")
    widgets['difficulty'].pack()
    widgets['difficulty'].configure(state='disabled') 
  
    widgets['continue'] = Button(win, text="Continue", command=lambda:ok_fine_lets_play(win, widgets, character, game, max_hp, level))
    widgets['continue'].place(x=300, y=280, anchor='c') 
  
    def ok_fine_lets_play(win, widgets, character, game, max_hp, level):
      widgets = page_transition(widgets)
        
      # essentially keeps going until one character is at 0 HP
      if not (character.hp == 0 or level.opponent.hp == 0):
        widgets['visual_frame'] = Frame(win)
        widgets['visual_frame'].place(x=300, y=150, anchor='c')
  
        # add characters' avatars and icons
        widgets['your_avatar'] = Label(widgets['visual_frame'], text=character.avatar, font=SMALLER_FONT)
        widgets['your_avatar'].pack(side=LEFT)
        widgets['your_icon'] = Label(widgets['visual_frame'], text=" "*6+("\n"*6), font=SMALLER_FONT)
        widgets['your_icon'].pack(side=LEFT)
        widgets['their_icon'] = Label(widgets['visual_frame'], text=" "*6+("\n"*6), font=SMALLER_FONT)
        widgets['their_icon'].pack(side=LEFT)
        widgets['their_avatar'] = Label(widgets['visual_frame'], text=level.opponent.avatar, font=SMALLER_FONT)
        widgets['their_avatar'].pack(side=LEFT)

        # for special enemies
        if 'silver' in level.opponent.species:
          widgets['their_avatar'].configure(fg=SILVER)
        if 'gold' in level.opponent.species:
          widgets['their_avatar'].configure(fg=GOLD)

        widgets['hp_frame'] = Frame(win)
        widgets['hp_frame'].place(x=300, y=220, anchor='c')

        widgets['your_hp'] = Label(widgets['hp_frame'], text=f"HP: {character.hp}     ", font=SMALLER_FONT)
        widgets['your_hp'].pack(side=LEFT)
        widgets['their_hp'] = Label(widgets['hp_frame'], text=f"     HP: {level.opponent.hp}", font=SMALLER_FONT)
        widgets['their_hp'].pack(side=RIGHT)

        widgets['buttons_frame'] = Frame(win)
        widgets['buttons_frame'].place(x=300, y=250, anchor='c')

        # disengage and attack buttons
        widgets['disengage'] = Button(widgets['buttons_frame'], text="Disengage", command=lambda: disengage(win, widgets, character, game, max_hp, level))
        widgets['disengage'].pack(side=LEFT)
        widgets['attack'] = Button(widgets['buttons_frame'], text="Attack", command=lambda: attack(win, widgets, character, game, max_hp, level))
        widgets['attack'].pack(side=RIGHT)

        if level.opponent.hp == 0:
          widgets['message'] = Label(win, text=f"Success, you have defeated {level.opponent.name}!", fg=GREEN)
          widgets['message'].place(x=300, y=250)
          main_game(win, widgets, character, game, max_hp)
        elif character.hp == 0:
          widgets['message'] = Label(win, text=f"Failure, you have been defeated by {level.opponent.name}!", fg=RED)
          widgets['message'].place(x=300, y=250)
          main_game(win, widgets, character, game, max_hp)


# battle options
def disengage(win, widgets, character, game, max_hp, level):
  widgets['your_icon'].configure(text=DISENGAGE)
  their_option = random.choice(['disengage', 'attack'])
  if their_option == 'attack':
    widgets['their_icon'].configure(text="\n".join(line[::-1] for line in ATTACK.split("\n"))) # reverse sword!
    their_attack = level.roller.roll() + level.opponent.stats[character.primary_stat].get_modifier()
    if their_attack <= 5:
      level.opponent.hp -= int(level.opponent.damage * 1.5)
      if their_attack >= 20:
        level.opponent.hp += level.opponent.damage
    if level.opponent.hp < 0:
      level.opponent.hp = 0
    widgets['their_hp'].configure(text=f"     HP: {level.opponent.hp}")
  else:
    widgets['their_icon'].configure(text=DISENGAGE)

  if level.opponent.hp == 0:
    widgets['message'] = Label(win, text=f"Success, you have defeated {level.opponent.name}!", fg=GREEN)
    widgets['message'].place(x=300, y=250)
    main_game(win, widgets, character, game, max_hp)

def attack(win, widgets, character, game, max_hp, level):
  widgets['your_icon'].configure(text=ATTACK)
  your_attack = level.roller.roll() + character.stats[level.key_stat].get_modifier() # modifier of level's key stat applied
  if 5 < your_attack < level.difficulty:
    character.hp -= character.damage
  elif your_attack <= 5:
    character.hp -= int(character.damage * 1.5)
  elif your_attack >= 20:
    character.hp += character.damage
  their_option = random.choice(['disengage', 'attack'])
  if their_option == 'attack':
    widgets['their_icon'].configure(text="\n".join(line[::-1] for line in ATTACK.split("\n")))
  if your_attack > level.difficulty:
    level.opponent.hp -= level.opponent.damage
    if your_attack >= 20:
      level.opponent.hp -= int(character.damage * 1.5)
    their_attack = level.roller.roll() + level.opponent.stats[character.primary_stat].get_modifier()
    if their_attack <= 5:
      level.opponent.hp -= int(level.opponent.damage * 1.5)
    if their_attack >= 20:
      level.opponent.hp += level.opponent.damage
    if level.opponent.hp < 0:
      level.opponent.hp = 0
  else:
    widgets['their_icon'].configure(text=DISENGAGE)
    if level.opponent.hp < 0:
      level.opponent.hp = 0
    if character.hp < 0:
      character.hp = 0
  widgets['your_hp'].configure(text=f"HP: {character.hp}     ")
  widgets['their_hp'].configure(text=f"     HP: {level.opponent.hp}")

  if level.opponent.hp == 0:
    widgets['message'] = Label(win, text=f"Success, you have defeated {level.opponent.name}!", fg=GREEN)
    widgets['message'].place(x=300, y=250)
    main_game(win, widgets, character, game, max_hp)
  elif character.hp == 0:
    widgets['message'] = Label(win, text=f"Failure, you have been defeated by {level.opponent.name}!", fg=RED)
    widgets['message'].place(x=300, y=250)
    main_game(win, widgets, character, game, max_hp)
    
def get_game_info(win, widgets, character, game, max_hp):
  widgets = page_transition(widgets)

  if game.current_enemy != None:
    widgets['game_info'] = Text(win, wrap=WORD, font=SMALLER_FONT)
    widgets['game_info'].insert(INSERT, game.game_info())
    widgets['game_info'].pack()
    widgets['game_info'].configure(state='disabled')
  else:
    widgets['message'] = Label(win, text="You haven't started a level yet!", font=BOLD_FONT)
    widgets['message'].place(x=300, y=200, anchor='c')

  widgets['continue'] = Button(win, text="Continue", command=lambda:main_game(win, widgets, character, game, max_hp))
  widgets['continue'].place(x=300, y=280, anchor='c') 

def get_character_info(win, widgets, character, game, max_hp):
  widgets = page_transition(widgets)

  widgets['character_info'] = Text(win, wrap=WORD, font=SMALLER_FONT)
  
  widgets['character_info'].insert(INSERT, character.avatar)
  widgets['character_info'].insert(INSERT, "\n" + character.get_stats())
  
  widgets['character_info'].pack()
  widgets['character_info'].configure(state='disabled')

  widgets['continue'] = Button(win, text="Continue", command=lambda:main_game(win, widgets, character, game, max_hp))
  widgets['continue'].place(x=300, y=280, anchor='c') 